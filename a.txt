============================= test session starts ==============================
platform linux -- Python 3.8.10, pytest-7.1.1, pluggy-1.0.0
rootdir: /home/gaetan/r_place, configfile: pytest.ini
plugins: cairo-0.1.0, asyncio-0.18.3, web3-5.29.0, cov-3.0.0, typeguard-2.13.3
asyncio: mode=auto
collected 1 item

tests/test_r_place.py F                                                  [100%]

=================================== FAILURES ===================================
_____________________________ test_play_x_invalid ______________________________

self = <starkware.cairo.lang.vm.vm_core.VirtualMachine object at 0x7f5a446d8220>
code = <code object <module> at 0x7f5a3fd39030, file "<hint2>", line 1>
globals_ = {'PRIME': 361850278866613121...3092056135872020481, '__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'As... 'BaseException': <class 'BaseException'>, ...}, '__find_element_max_size': 1048576, '__keccak_max_size': 1048576, ...}
hint_index = 0

    def exec_hint(self, code, globals_, hint_index):
        """
        Executes the given code with the given globals.
        This function can be overridden by subclasses.
        """
        try:
>           exec(code, globals_)

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   AssertionError: a = 3618502788666131213697322783095070105623107215331596699973092056135872020480 is out of range.

<hint2>:3: AssertionError

During handling of the above exception, another exception occurred:

self = ExecuteEntryPoint(contract_address=2432376701145892581813756758520827448503514832517541520680671909297005928883, code_...0439035013300773059621285230056, entry_point_type=<EntryPointType.EXTERNAL: 0>, calldata=[100, 9, 9], caller_address=0)
state = CarriedState(shared_state={"block_info": {"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, "contract_sta..., {}), block_info={"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, syscall_counter=ChainMap({}, {}, {}))
general_config = StarknetGeneralConfig(starknet_os_config=StarknetOsConfig(chain_id=<StarknetChainId.TESTNET: 1536727068981429685321>, ...'range_check_builtin': 0.0, 'ecdsa_builtin': 0.0, 'bitwise_builtin': 0.0, 'output_builtin': 0.0, 'ec_op_builtin': 0.0})
loop = <_UnixSelectorEventLoop running=False closed=False debug=False>
tx_execution_context = TransactionExecutionContext(account_contract_address=24323767011458925818137567585208274485035148325175415206806719092... signature=[], max_fee=0, version=0, run_resources=RunResources(n_steps=999961), n_emitted_events=0, n_sent_messages=0)

    def _run(
        self,
        state: CarriedState,
        general_config: StarknetGeneralConfig,
        loop: asyncio.AbstractEventLoop,
        tx_execution_context: TransactionExecutionContext,
    ) -> Tuple[CairoFunctionRunner, syscall_utils.BusinessLogicSysCallHandler]:
        """
        Runs the selected entry point with the given calldata in the code of the contract deployed
        at self.code_address.
        The execution is done in the context (e.g., storage) of the contract at
        self.contract_address.
        Returns the corresponding CairoFunctionRunner and BusinessLogicSysCallHandler in order to
        retrieve the execution information.
        """
        # Extract pre-fetched contract code from carried state.
        code_contract_state = state.contract_states[self.code_address].state
        code_contract_state.assert_initialized(contract_address=self.code_address)
    
        # Prepare input for Cairo function runner.
        contract_definition = state.contract_definitions[code_contract_state.contract_hash]
        contract_definition.validate()
        entry_point = self._get_selected_entry_point(contract_definition=contract_definition)
    
        # Run the specified contract entry point with given calldata.
        with wrap_with_stark_exception(code=StarknetErrorCode.SECURITY_ERROR):
            runner = CairoFunctionRunner(program=contract_definition.program, layout="all")
        os_context = os_utils.prepare_os_context(runner=runner)
    
        # Extract pre-fetched contract state from carried state.
        pre_run_contract_carried_state = state.contract_states[self.contract_address]
        contract_state = pre_run_contract_carried_state.state
        contract_state.assert_initialized(contract_address=self.contract_address)
    
        starknet_storage = BusinessLogicStarknetStorage(
            commitment_tree=contract_state.storage_commitment_tree,
            ffc=state.ffc,
            # Note that pending_modifications might be modified during the run as a result of an
            # internal call.
            pending_modifications=pre_run_contract_carried_state.storage_updates.copy(),
            loop=loop,
        )
    
        initial_syscall_ptr = cast(RelocatableValue, os_context[starknet_abi.SYSCALL_PTR_OFFSET])
        syscall_handler = syscall_utils.BusinessLogicSysCallHandler(
            execute_entry_point_cls=ExecuteEntryPoint,
            tx_execution_context=tx_execution_context,
            state=state,
            caller_address=self.caller_address,
            contract_address=self.contract_address,
            starknet_storage=starknet_storage,
            general_config=general_config,
            initial_syscall_ptr=initial_syscall_ptr,
        )
    
        # Positional arguments are passed to *args in the 'run_from_entrypoint' function.
        entry_points_args = [
            self.entry_point_selector,
            os_context,
            len(self.calldata),
            self.calldata,
        ]
    
        try:
>           runner.run_from_entrypoint(
                entry_point.offset,
                *entry_points_args,
                hint_locals={
                    "__storage": starknet_storage,
                    "syscall_handler": syscall_handler,
                },
                static_locals={
                    "__find_element_max_size": 2 ** 20,
                    "__squash_dict_max_size": 2 ** 20,
                    "__keccak_max_size": 2 ** 20,
                    "__usort_max_size": 2 ** 20,
                },
                run_resources=tx_execution_context.run_resources,
                verify_secure=True,
            )

../cairo_venv/lib/python3.8/site-packages/starkware/starknet/business_logic/execution/execute_entry_point.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starkware.cairo.common.cairo_function_runner.CairoFunctionRunner object at 0x7f5a44b7fbb0>
entrypoint = 359, typed_args = False
hint_locals = {'__storage': <starkware.starknet.storage.starknet_storage.BusinessLogicStarknetStorage object at 0x7f5a44bb4040>, 'syscall_handler': <starkware.starknet.core.os.syscall_utils.BusinessLogicSysCallHandler object at 0x7f5a44bb4f70>}
static_locals = {'__find_element_max_size': 1048576, '__keccak_max_size': 1048576, '__squash_dict_max_size': 1048576, '__usort_max_size': 1048576}
run_resources = RunResources(n_steps=999961)

    def run_from_entrypoint(
        self,
        entrypoint: Union[str, int],
        *args,
        typed_args: Optional[bool] = False,
        hint_locals: Optional[Dict[str, Any]] = None,
        static_locals: Optional[Dict[str, Any]] = None,
        run_resources: Optional[RunResources] = None,
        verify_secure: Optional[bool] = None,
        apply_modulo_to_args: Optional[bool] = None,
    ):
        """
        Runs the program from the given entrypoint.
    
        Additional params:
        typed_args - If true, the arguments are given as Cairo typed NamedTuple generated
          with CairoStructFactory.
        verify_secure - Run verify_secure_runner to do extra verifications.
        apply_modulo_to_args - Apply modulo operation on integer arguments.
        """
        if hint_locals is None:
            hint_locals = {}
    
        if verify_secure is None:
            verify_secure = True
    
        if apply_modulo_to_args is None:
            apply_modulo_to_args = True
    
        if typed_args:
            assert len(args) == 1, "len(args) must be 1 when using typed args."
            real_args = self.segments.gen_typed_args(args=args[0])
        else:
            real_args = [
                self.gen_arg(arg=x, apply_modulo_to_args=apply_modulo_to_args) for x in args
            ]
        end = self.initialize_function_entrypoint(entrypoint=entrypoint, args=real_args)
        self.initialize_vm(hint_locals=hint_locals, static_locals=static_locals)
    
>       self.run_until_pc(addr=end, run_resources=run_resources)

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/common/cairo_function_runner.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starkware.cairo.common.cairo_function_runner.CairoFunctionRunner object at 0x7f5a44b7fbb0>
addr = RelocatableValue(segment_index=11, offset=0)
run_resources = RunResources(n_steps=999961)

    def run_until_pc(self, addr: MaybeRelocatable, run_resources: Optional[RunResources] = None):
        """
        Runs the VM until pc reaches 'addr', and stop right before that instruction is executed.
        """
        if run_resources is None:
            run_resources = RunResources(n_steps=None)
    
        while self.vm.run_context.pc != addr and not run_resources.consumed:
>           self.vm_step()

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/cairo_runner.py:292: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starkware.cairo.common.cairo_function_runner.CairoFunctionRunner object at 0x7f5a44b7fbb0>

    def vm_step(self):
        if self.vm.run_context.pc == self.final_pc:
            raise self.vm.as_vm_exception(
                Exception("Error: Execution reached the end of the program."),
                with_traceback=False,
            )
>       self.vm.step()

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/cairo_runner.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starkware.cairo.lang.vm.vm_core.VirtualMachine object at 0x7f5a446d8220>

    def step(self):
        self.skip_instruction_execution = False
        # Execute hints.
        for hint_index, hint in enumerate(self.hints.get(self.run_context.pc, [])):
            exec_locals = self.exec_scopes[-1]
            exec_locals["memory"] = memory = self.validated_memory
            exec_locals["ap"] = ap = self.run_context.ap
            exec_locals["fp"] = fp = self.run_context.fp
            exec_locals["pc"] = pc = self.run_context.pc
            exec_locals["current_step"] = self.current_step
            exec_locals["ids"] = hint.consts(pc, ap, fp, memory)
    
            exec_locals["vm_load_program"] = self.load_program
            exec_locals["vm_enter_scope"] = self.enter_scope
            exec_locals["vm_exit_scope"] = self.exit_scope
            exec_locals.update(self.static_locals)
    
>           self.exec_hint(hint.compiled, exec_locals, hint_index=hint_index)

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/vm_core.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starkware.cairo.lang.vm.vm_core.VirtualMachine object at 0x7f5a446d8220>
code = <code object <module> at 0x7f5a3fd39030, file "<hint2>", line 1>
globals_ = {'PRIME': 361850278866613121...3092056135872020481, '__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'As... 'BaseException': <class 'BaseException'>, ...}, '__find_element_max_size': 1048576, '__keccak_max_size': 1048576, ...}
hint_index = 0

    def exec_hint(self, code, globals_, hint_index):
        """
        Executes the given code with the given globals.
        This function can be overridden by subclasses.
        """
        try:
            exec(code, globals_)
        except Exception:
            hint_exception = HintException(self, *sys.exc_info())
>           raise self.as_vm_exception(
                hint_exception, notes=[hint_exception.exception_str], hint_index=hint_index
            ) from None

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py:294: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starkware.cairo.lang.vm.vm_core.VirtualMachine object at 0x7f5a446d8220>
exc = HintException('Got an exception while executing a hint.')
with_traceback = True
notes = ['Traceback (most recent call last):\n  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/comm...\nAssertionError: a = 3618502788666131213697322783095070105623107215331596699973092056135872020480 is out of range.\n']
hint_index = 0

    def as_vm_exception(
        self,
        exc,
        with_traceback: bool = True,
        notes: Optional[List[str]] = None,
        hint_index: Optional[int] = None,
    ):
        """
        Wraps the exception with a VmException, adding to it location information.
        The current pc is used.
        """
        pc = self.run_context.pc
>       traceback = self.get_traceback() if with_traceback else None

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py:310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starkware.cairo.lang.vm.vm_core.VirtualMachine object at 0x7f5a446d8220>

    def get_traceback(self) -> Optional[str]:
        """
        Returns the traceback at the current pc.
        """
        traceback = ""
        for fp, traceback_pc in self.run_context.get_traceback_entries():
>           traceback += self.get_error_attr_value(pc=traceback_pc, fp=fp)

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starkware.cairo.lang.vm.vm_core.VirtualMachine object at 0x7f5a446d8220>
pc = RelocatableValue(segment_index=0, offset=393)
fp = RelocatableValue(segment_index=1, offset=38)

    def get_error_attr_value(self, pc, fp) -> str:
        """
        Returns the error messages that correspond to the error_message attribute scopes surrounding
        the given pc.
        """
        errors = ""
        for error_message_attr in self.error_message_attributes:
            if error_message_attr.start_pc <= pc < error_message_attr.end_pc:
>               error_message = self.substitute_error_message_references(error_message_attr, fp)

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py:402: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starkware.cairo.lang.vm.vm_core.VirtualMachine object at 0x7f5a446d8220>
error_message_attr = VmAttributeScope(name='error_message', value='Invalid x: should be <={X}', start_pc=RelocatableValue(segment_index=0, ...eck_ptr')): 222}), accessible_scopes=[ScopedName(path=('__main__',)), ScopedName(path=('__main__', 'assert_x_valid'))])
fp = RelocatableValue(segment_index=1, offset=38)

    def substitute_error_message_references(self, error_message_attr: VmAttributeScope, fp) -> str:
        """
        Substitutes references in the given error_message attribute with their actual value.
        References are defined with '{}'. E.g., 'x must be positive. Got: {x}'.
        """
        error_message = error_message_attr.value
        if error_message_attr.flow_tracking_data is None:
            return error_message
        flow_tracking_data = error_message_attr.flow_tracking_data
    
        invalid_references = []
    
        def substitute_ref(match):
            reference = match.group("name")
            try:
                val = self.evaluate_reference(
                    name=reference,
                    accessible_scopes=error_message_attr.accessible_scopes,
                    flow_tracking_data=flow_tracking_data,
                    fp=fp,
                )
                return decimal_repr(val, self.prime)
            except (ApDeductionError, InvalidReferenceExpressionError):
                invalid_references.append(reference)
                return match.group(0)
    
>       error_message = re.sub(r"{(?P<name>[a-zA-Z_0-9.]+)}", substitute_ref, error_message)

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py:386: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pattern = '{(?P<name>[a-zA-Z_0-9.]+)}'
repl = <function VirtualMachineBase.substitute_error_message_references.<locals>.substitute_ref at 0x7f5a3feed280>
string = 'Invalid x: should be <={X}', count = 0, flags = 0

    def sub(pattern, repl, string, count=0, flags=0):
        """Return the string obtained by replacing the leftmost
        non-overlapping occurrences of the pattern in string by the
        replacement repl.  repl can be either a string or a callable;
        if a string, backslash escapes in it are processed.  If it is
        a callable, it's passed the Match object and must return
        a replacement string to be used."""
>       return _compile(pattern, flags).sub(repl, string, count)

/usr/lib/python3.8/re.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

match = <re.Match object; span=(23, 26), match='{X}'>

    def substitute_ref(match):
        reference = match.group("name")
        try:
>           val = self.evaluate_reference(
                name=reference,
                accessible_scopes=error_message_attr.accessible_scopes,
                flow_tracking_data=flow_tracking_data,
                fp=fp,
            )

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py:375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starkware.cairo.lang.vm.vm_core.VirtualMachine object at 0x7f5a446d8220>
name = 'X'
accessible_scopes = [ScopedName(path=('__main__',)), ScopedName(path=('__main__', 'assert_x_valid'))]
flow_tracking_data = FlowTrackingDataActual(ap_tracking=RegTrackingData(group=33, offset=0), reference_ids={ScopedName(path=('__main__', 'a...__', 'assert_x_valid', 'pedersen_ptr')): 221, ScopedName(path=('__main__', 'assert_x_valid', 'range_check_ptr')): 222})
fp = RelocatableValue(segment_index=1, offset=38)

    def evaluate_reference(
        self,
        name: str,
        accessible_scopes: List[ScopedName],
        flow_tracking_data: FlowTrackingDataActual,
        fp: MaybeRelocatable,
    ) -> MaybeRelocatable:
        """
        Returns the value of the given reference with respect to the given fp.
        If the reference is ap-based, ApDeductionError is thrown.
        """
        assert isinstance(self.program, Program)
        identifier = self.program.identifiers.search(
            accessible_scopes=accessible_scopes, name=ScopedName.from_string(name)
        )
>       reference = flow_tracking_data.resolve_reference(
            reference_manager=self.program.reference_manager,
            name=identifier.get_canonical_name(),
        )

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = FlowTrackingDataActual(ap_tracking=RegTrackingData(group=33, offset=0), reference_ids={ScopedName(path=('__main__', 'a...__', 'assert_x_valid', 'pedersen_ptr')): 221, ScopedName(path=('__main__', 'assert_x_valid', 'range_check_ptr')): 222})
reference_manager = ReferenceManager(references=[Reference(pc=3, value=ExprDeref(addr=ExprCast(expr=ExprOperator(a=ExprReg(reg=<Register.F...e), location=:1:1), ap_tracking_data=RegTrackingData(group=36, offset=0), locations=[], definition_code_element=None)])
name = ScopedName(path=('__main__', 'X'))

    def resolve_reference(self, reference_manager: ReferenceManager, name: ScopedName) -> Reference:
        ref_id = self.reference_ids.get(name)
        if ref_id is None:
>           raise MissingReferenceError(f"Missing reference {name}.")
E           starkware.cairo.lang.compiler.preprocessor.flow.MissingReferenceError: Missing reference __main__.X.

../cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/compiler/preprocessor/flow.py:143: MissingReferenceError

During handling of the above exception, another exception occurred:

fun = <coroutine object StarknetContractFunctionInvocation.invoke at 0x7f5a458637c0>
reverted_with = 'Invalid x: should be <={X}'

    async def assert_revert(fun, reverted_with=None):
        try:
>           await fun

tests/utils.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = StarknetContractFunctionInvocation(state=<starkware.starknet.testing.state.StarknetState object at 0x7f5a45808340>, st...tdata_arg_types=[], retdata_tuple=<class 'starkware.starknet.testing.contract.play_return_type'>, has_raw_output=False)
caller_address = 0, max_fee = 0, signature = None

    async def invoke(
        self, caller_address: int = 0, max_fee: int = 0, signature: List[int] = None
    ) -> StarknetTransactionExecutionInfo:
        """
        Executes the function call and apply changes on the state.
        """
>       return await self._invoke_on_given_state(
            state=self.state, caller_address=caller_address, max_fee=max_fee, signature=signature
        )

../cairo_venv/lib/python3.8/site-packages/starkware/starknet/testing/contract.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = StarknetContractFunctionInvocation(state=<starkware.starknet.testing.state.StarknetState object at 0x7f5a45808340>, st...tdata_arg_types=[], retdata_tuple=<class 'starkware.starknet.testing.contract.play_return_type'>, has_raw_output=False)
state = <starkware.starknet.testing.state.StarknetState object at 0x7f5a45808340>
caller_address = 0, max_fee = 0, signature = None

    async def _invoke_on_given_state(
        self,
        state: StarknetState,
        caller_address: int = 0,
        max_fee: int = 0,
        signature: List[int] = None,
    ) -> StarknetTransactionExecutionInfo:
        """
        Executes the function call and apply changes on the given state.
        """
>       execution_info = await state.invoke_raw(
            contract_address=self.contract_address,
            selector=self.name,
            calldata=self.calldata,
            caller_address=caller_address,
            max_fee=max_fee,
            signature=None if signature is None else cast_to_felts(values=signature),
        )

../cairo_venv/lib/python3.8/site-packages/starkware/starknet/testing/contract.py:303: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starkware.starknet.testing.state.StarknetState object at 0x7f5a45808340>
contract_address = 243237670114589258...0671909297005928883
selector = 954608513507510209...0773059621285230056, calldata = [100, 9, 9]
caller_address = 0, max_fee = 0, signature = []
entry_point_type = <EntryPointType.EXTERNAL: 0>, nonce = None

    async def invoke_raw(
        self,
        contract_address: CastableToAddress,
        selector: Union[int, str],
        calldata: List[int],
        caller_address: int,
        max_fee: int,
        signature: Optional[List[int]] = None,
        entry_point_type: EntryPointType = EntryPointType.EXTERNAL,
        nonce: Optional[int] = None,
    ) -> TransactionExecutionInfo:
        """
        Invokes a contract function. Returns the execution info.
    
        Args:
        contract_address - a hexadecimal string or an integer representing the contract address.
        selector - either a function name or an integer selector for the entrypoint to invoke.
        calldata - a list of integers to pass as calldata to the invoked function.
        signature - a list of integers to pass as signature to the invoked function.
        """
    
        if isinstance(contract_address, str):
            contract_address = int(contract_address, 16)
        assert isinstance(contract_address, int)
    
        if isinstance(selector, str):
            selector = get_selector_from_name(selector)
        assert isinstance(selector, int)
    
        if signature is None:
            signature = []
    
        tx = InternalInvokeFunction.create(
            contract_address=contract_address,
            entry_point_selector=selector,
            entry_point_type=entry_point_type,
            calldata=calldata,
            max_fee=max_fee,
            signature=signature,
            caller_address=caller_address,
            nonce=nonce,
            chain_id=self.general_config.chain_id.value,
            version=constants.TRANSACTION_VERSION,
        )
    
        with self.state.copy_and_apply() as state_copy:
>           tx_execution_info = await tx.apply_state_updates(
                state=state_copy, general_config=self.general_config
            )

../cairo_venv/lib/python3.8/site-packages/starkware/starknet/testing/state.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = InternalInvokeFunction(contract_address=2432376701145892581813756758520827448503514832517541520680671909297005928883, ...once=None, code_address=2432376701145892581813756758520827448503514832517541520680671909297005928883, caller_address=0)
state = CarriedState(shared_state={"block_info": {"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, "contract_sta...p({}, {}), block_info={"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, syscall_counter=ChainMap({}, {}))
general_config = StarknetGeneralConfig(starknet_os_config=StarknetOsConfig(chain_id=<StarknetChainId.TESTNET: 1536727068981429685321>, ...'range_check_builtin': 0.0, 'ecdsa_builtin': 0.0, 'bitwise_builtin': 0.0, 'output_builtin': 0.0, 'ec_op_builtin': 0.0})

    async def apply_state_updates(
        self, state: CarriedStateBase, general_config: Config
    ) -> TransactionExecutionInfo:
        # super().apply_state_updates calls InternalStateTransaction.apply_state_updates
        # that calls self._apply_specific_state_updates and therefore does not return None.
>       tx_execution_info = await super().apply_state_updates(
            state=state, general_config=general_config
        )

../cairo_venv/lib/python3.8/site-packages/starkware/starknet/business_logic/internal_transaction.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = InternalInvokeFunction(contract_address=2432376701145892581813756758520827448503514832517541520680671909297005928883, ...once=None, code_address=2432376701145892581813756758520827448503514832517541520680671909297005928883, caller_address=0)
state = CarriedState(shared_state={"block_info": {"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, "contract_sta...p({}, {}), block_info={"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, syscall_counter=ChainMap({}, {}))
general_config = StarknetGeneralConfig(starknet_os_config=StarknetOsConfig(chain_id=<StarknetChainId.TESTNET: 1536727068981429685321>, ...'range_check_builtin': 0.0, 'ecdsa_builtin': 0.0, 'bitwise_builtin': 0.0, 'output_builtin': 0.0, 'ec_op_builtin': 0.0})

    async def apply_state_updates(
        self, state: CarriedStateBase, general_config: Config
    ) -> Optional[TransactionExecutionInfo]:
        """
        Applies the transaction on the commitment tree state in an atomic manner.
        """
        # Downcast arguments to application-specific types.
        assert isinstance(state, CarriedState)
        assert isinstance(general_config, StarknetGeneralConfig)
    
        with state.copy_and_apply() as state_to_update:
            try:
>               execution_info = await self._apply_specific_state_updates(
                    state=state_to_update, general_config=general_config
                )

../cairo_venv/lib/python3.8/site-packages/starkware/starknet/business_logic/internal_transaction_interface.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = InternalInvokeFunction(contract_address=2432376701145892581813756758520827448503514832517541520680671909297005928883, ...once=None, code_address=2432376701145892581813756758520827448503514832517541520680671909297005928883, caller_address=0)
state = CarriedState(shared_state={"block_info": {"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, "contract_sta..., {}), block_info={"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, syscall_counter=ChainMap({}, {}, {}))
general_config = StarknetGeneralConfig(starknet_os_config=StarknetOsConfig(chain_id=<StarknetChainId.TESTNET: 1536727068981429685321>, ...'range_check_builtin': 0.0, 'ecdsa_builtin': 0.0, 'bitwise_builtin': 0.0, 'output_builtin': 0.0, 'ec_op_builtin': 0.0})

    async def _apply_specific_state_updates(
        self, state: CarriedState, general_config: StarknetGeneralConfig
    ) -> TransactionExecutionInfo:
        """
        Applies self to 'state' by executing the entry point and charging fee for it (if needed).
        """
>       call_info = await self.execute(state=state, general_config=general_config)

../cairo_venv/lib/python3.8/site-packages/starkware/starknet/business_logic/internal_transaction.py:598: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = InternalInvokeFunction(contract_address=2432376701145892581813756758520827448503514832517541520680671909297005928883, ...once=None, code_address=2432376701145892581813756758520827448503514832517541520680671909297005928883, caller_address=0)
state = CarriedState(shared_state={"block_info": {"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, "contract_sta..., {}), block_info={"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, syscall_counter=ChainMap({}, {}, {}))
general_config = StarknetGeneralConfig(starknet_os_config=StarknetOsConfig(chain_id=<StarknetChainId.TESTNET: 1536727068981429685321>, ...'range_check_builtin': 0.0, 'ecdsa_builtin': 0.0, 'bitwise_builtin': 0.0, 'output_builtin': 0.0, 'ec_op_builtin': 0.0})
only_query = False

    async def execute(
        self, state: CarriedState, general_config: StarknetGeneralConfig, only_query: bool = False
    ) -> CallInfo:
        """
        Builds the transaction execution context and executes the entry point.
        Returns the CallInfo.
        """
        # Sanity check for query mode.
        if only_query:
            error_message = "Illegal version for querying"
            allowed_versions = [constants.QUERY_VERSION, constants.TRANSACTION_VERSION]
        else:
            error_message = "Illegal transaction version"
            allowed_versions = [constants.TRANSACTION_VERSION]
        assert self.version in allowed_versions, f"{error_message}: {self.version}."
    
        tx_execution_context = TransactionExecutionContext.create(
            account_contract_address=self.contract_address,
            transaction_hash=self.hash_value,
            signature=self.signature,
            max_fee=self.max_fee,
            n_steps=general_config.invoke_tx_max_n_steps,
            version=self.version,
        )
        call = ExecuteEntryPoint(
            contract_address=self.contract_address,
            code_address=self.code_address,
            entry_point_selector=self.entry_point_selector,
            entry_point_type=self.entry_point_type,
            calldata=self.calldata,
            caller_address=self.caller_address,
        )
    
>       return await call.execute(
            state=state, general_config=general_config, tx_execution_context=tx_execution_context
        )

../cairo_venv/lib/python3.8/site-packages/starkware/starknet/business_logic/internal_transaction.py:662: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ExecuteEntryPoint(contract_address=2432376701145892581813756758520827448503514832517541520680671909297005928883, code_...0439035013300773059621285230056, entry_point_type=<EntryPointType.EXTERNAL: 0>, calldata=[100, 9, 9], caller_address=0)
state = CarriedState(shared_state={"block_info": {"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, "contract_sta..., {}), block_info={"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, syscall_counter=ChainMap({}, {}, {}))
general_config = StarknetGeneralConfig(starknet_os_config=StarknetOsConfig(chain_id=<StarknetChainId.TESTNET: 1536727068981429685321>, ...'range_check_builtin': 0.0, 'ecdsa_builtin': 0.0, 'bitwise_builtin': 0.0, 'output_builtin': 0.0, 'ec_op_builtin': 0.0})
tx_execution_context = TransactionExecutionContext(account_contract_address=24323767011458925818137567585208274485035148325175415206806719092... signature=[], max_fee=0, version=0, run_resources=RunResources(n_steps=999961), n_emitted_events=0, n_sent_messages=0)

    async def execute(
        self,
        state: CarriedState,
        general_config: StarknetGeneralConfig,
        tx_execution_context: TransactionExecutionContext,
    ) -> CallInfo:
        """
        Executes the selected entry point with the given calldata in the specified contract.
        The information collected from this run (number of steps required, modifications to the
        contract storage, etc.) is saved on the carried state argument.
        Returns a CallInfo object that represents the execution.
        """
        # Pass the running loop before entering to it. It will be used to run asynchronous
        # tasks, such as fetching data from storage.
        loop: asyncio.AbstractEventLoop = asyncio.get_event_loop()
        sync_execute = functools.partial(
            self.sync_execute,
            state=state,
            general_config=general_config,
            loop=loop,
            tx_execution_context=tx_execution_context,
        )
    
>       return await loop.run_in_executor(
            executor=None,  # Runs on the default executor.
            func=sync_execute,
        )

../cairo_venv/lib/python3.8/site-packages/starkware/starknet/business_logic/execution/execute_entry_point.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = None

    def run(self):
        if not self.future.set_running_or_notify_cancel():
            return
    
        try:
>           result = self.fn(*self.args, **self.kwargs)

/usr/lib/python3.8/concurrent/futures/thread.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ExecuteEntryPoint(contract_address=2432376701145892581813756758520827448503514832517541520680671909297005928883, code_...0439035013300773059621285230056, entry_point_type=<EntryPointType.EXTERNAL: 0>, calldata=[100, 9, 9], caller_address=0)
state = CarriedState(shared_state={"block_info": {"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, "contract_sta..., {}), block_info={"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, syscall_counter=ChainMap({}, {}, {}))
general_config = StarknetGeneralConfig(starknet_os_config=StarknetOsConfig(chain_id=<StarknetChainId.TESTNET: 1536727068981429685321>, ...'range_check_builtin': 0.0, 'ecdsa_builtin': 0.0, 'bitwise_builtin': 0.0, 'output_builtin': 0.0, 'ec_op_builtin': 0.0})
loop = <_UnixSelectorEventLoop running=False closed=False debug=False>
tx_execution_context = TransactionExecutionContext(account_contract_address=24323767011458925818137567585208274485035148325175415206806719092... signature=[], max_fee=0, version=0, run_resources=RunResources(n_steps=999961), n_emitted_events=0, n_sent_messages=0)

    def sync_execute(
        self,
        state: CarriedState,
        general_config: StarknetGeneralConfig,
        loop: asyncio.AbstractEventLoop,
        tx_execution_context: TransactionExecutionContext,
    ) -> CallInfo:
        """
        Synchronous version of execute_entry_point with a given TransactionExecutionContext object;
        needed since this function also runs inside Cairo hints (when processing internal contract
        calls).
        Should be called from whithin the given loop.
        """
        previous_cairo_usage = state.cairo_usage
    
>       runner, syscall_handler = self._run(
            state=state,
            general_config=general_config,
            loop=loop,
            tx_execution_context=tx_execution_context,
        )

../cairo_venv/lib/python3.8/site-packages/starkware/starknet/business_logic/execution/execute_entry_point.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ExecuteEntryPoint(contract_address=2432376701145892581813756758520827448503514832517541520680671909297005928883, code_...0439035013300773059621285230056, entry_point_type=<EntryPointType.EXTERNAL: 0>, calldata=[100, 9, 9], caller_address=0)
state = CarriedState(shared_state={"block_info": {"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, "contract_sta..., {}), block_info={"block_timestamp": 0, "gas_price": "0x0", "block_number": -1}, syscall_counter=ChainMap({}, {}, {}))
general_config = StarknetGeneralConfig(starknet_os_config=StarknetOsConfig(chain_id=<StarknetChainId.TESTNET: 1536727068981429685321>, ...'range_check_builtin': 0.0, 'ecdsa_builtin': 0.0, 'bitwise_builtin': 0.0, 'output_builtin': 0.0, 'ec_op_builtin': 0.0})
loop = <_UnixSelectorEventLoop running=False closed=False debug=False>
tx_execution_context = TransactionExecutionContext(account_contract_address=24323767011458925818137567585208274485035148325175415206806719092... signature=[], max_fee=0, version=0, run_resources=RunResources(n_steps=999961), n_emitted_events=0, n_sent_messages=0)

    def _run(
        self,
        state: CarriedState,
        general_config: StarknetGeneralConfig,
        loop: asyncio.AbstractEventLoop,
        tx_execution_context: TransactionExecutionContext,
    ) -> Tuple[CairoFunctionRunner, syscall_utils.BusinessLogicSysCallHandler]:
        """
        Runs the selected entry point with the given calldata in the code of the contract deployed
        at self.code_address.
        The execution is done in the context (e.g., storage) of the contract at
        self.contract_address.
        Returns the corresponding CairoFunctionRunner and BusinessLogicSysCallHandler in order to
        retrieve the execution information.
        """
        # Extract pre-fetched contract code from carried state.
        code_contract_state = state.contract_states[self.code_address].state
        code_contract_state.assert_initialized(contract_address=self.code_address)
    
        # Prepare input for Cairo function runner.
        contract_definition = state.contract_definitions[code_contract_state.contract_hash]
        contract_definition.validate()
        entry_point = self._get_selected_entry_point(contract_definition=contract_definition)
    
        # Run the specified contract entry point with given calldata.
        with wrap_with_stark_exception(code=StarknetErrorCode.SECURITY_ERROR):
            runner = CairoFunctionRunner(program=contract_definition.program, layout="all")
        os_context = os_utils.prepare_os_context(runner=runner)
    
        # Extract pre-fetched contract state from carried state.
        pre_run_contract_carried_state = state.contract_states[self.contract_address]
        contract_state = pre_run_contract_carried_state.state
        contract_state.assert_initialized(contract_address=self.contract_address)
    
        starknet_storage = BusinessLogicStarknetStorage(
            commitment_tree=contract_state.storage_commitment_tree,
            ffc=state.ffc,
            # Note that pending_modifications might be modified during the run as a result of an
            # internal call.
            pending_modifications=pre_run_contract_carried_state.storage_updates.copy(),
            loop=loop,
        )
    
        initial_syscall_ptr = cast(RelocatableValue, os_context[starknet_abi.SYSCALL_PTR_OFFSET])
        syscall_handler = syscall_utils.BusinessLogicSysCallHandler(
            execute_entry_point_cls=ExecuteEntryPoint,
            tx_execution_context=tx_execution_context,
            state=state,
            caller_address=self.caller_address,
            contract_address=self.contract_address,
            starknet_storage=starknet_storage,
            general_config=general_config,
            initial_syscall_ptr=initial_syscall_ptr,
        )
    
        # Positional arguments are passed to *args in the 'run_from_entrypoint' function.
        entry_points_args = [
            self.entry_point_selector,
            os_context,
            len(self.calldata),
            self.calldata,
        ]
    
        try:
            runner.run_from_entrypoint(
                entry_point.offset,
                *entry_points_args,
                hint_locals={
                    "__storage": starknet_storage,
                    "syscall_handler": syscall_handler,
                },
                static_locals={
                    "__find_element_max_size": 2 ** 20,
                    "__squash_dict_max_size": 2 ** 20,
                    "__keccak_max_size": 2 ** 20,
                    "__usort_max_size": 2 ** 20,
                },
                run_resources=tx_execution_context.run_resources,
                verify_secure=True,
            )
        except VmException as exception:
            code = StarknetErrorCode.TRANSACTION_FAILED
            if isinstance(exception.inner_exc, HintException):
                hint_exception = exception.inner_exc
    
                if isinstance(hint_exception.inner_exc, syscall_utils.HandlerException):
                    stark_exception = hint_exception.inner_exc.stark_exception
                    code = stark_exception.code
                    called_contract_address = hint_exception.inner_exc.called_contract_address
                    message_prefix = (
                        f"Error in the called contract ({hex(called_contract_address)}):\n"
                    )
                    # Override python's traceback and keep the Cairo one of the inner exception.
                    exception.notes = [message_prefix + str(stark_exception.message)]
    
            if isinstance(exception.inner_exc, ResourcesError):
                code = StarknetErrorCode.OUT_OF_RESOURCES
    
            raise StarkException(code=code, message=str(exception))
        except VmExceptionBase as exception:
            raise StarkException(code=StarknetErrorCode.TRANSACTION_FAILED, message=str(exception))
        except SecurityError as exception:
            raise StarkException(code=StarknetErrorCode.SECURITY_ERROR, message=str(exception))
        except Exception:
            logger.error("Got an unexpected exception.", exc_info=True)
>           raise StarkException(
                code=StarknetErrorCode.UNEXPECTED_FAILURE,
                message="Got an unexpected exception during the execution of the transaction.",
            )
E           starkware.starkware_utils.error_handling.StarkException: (500, {'code': <StarknetErrorCode.UNEXPECTED_FAILURE: 42>, 'message': 'Got an unexpected exception during the execution of the transaction.'})

../cairo_venv/lib/python3.8/site-packages/starkware/starknet/business_logic/execution/execute_entry_point.py:220: StarkException

During handling of the above exception, another exception occurred:

contract = <starkware.starknet.testing.contract.StarknetContract object at 0x7f5a44b76910>

    @pytest.mark.asyncio
    async def test_play_x_invalid(contract):
>       await assert_revert(contract.play(100,VALID_NR,VALID_NR).invoke(), "Invalid x: should be <={X}")

tests/test_r_place.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fun = <coroutine object StarknetContractFunctionInvocation.invoke at 0x7f5a458637c0>
reverted_with = 'Invalid x: should be <={X}'

    async def assert_revert(fun, reverted_with=None):
        try:
            await fun
            assert False
        except StarkException as err:
            _, error = err.args
            if reverted_with is not None:
>               assert reverted_with in error["message"]
E               AssertionError

tests/utils.py:12: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    starkware.starknet.business_logic.execution.execute_entry_point:execute_entry_point.py:219 Got an unexpected exception.
Traceback (most recent call last):
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py", line 291, in exec_hint
    exec(code, globals_)
  File "<hint2>", line 3, in <module>
AssertionError: a = 3618502788666131213697322783095070105623107215331596699973092056135872020480 is out of range.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/starknet/business_logic/execution/execute_entry_point.py", line 179, in _run
    runner.run_from_entrypoint(
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/common/cairo_function_runner.py", line 200, in run_from_entrypoint
    self.run_until_pc(addr=end, run_resources=run_resources)
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/cairo_runner.py", line 292, in run_until_pc
    self.vm_step()
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/cairo_runner.py", line 306, in vm_step
    self.vm.step()
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/vm_core.py", line 460, in step
    self.exec_hint(hint.compiled, exec_locals, hint_index=hint_index)
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py", line 294, in exec_hint
    raise self.as_vm_exception(
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py", line 310, in as_vm_exception
    traceback = self.get_traceback() if with_traceback else None
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py", line 412, in get_traceback
    traceback += self.get_error_attr_value(pc=traceback_pc, fp=fp)
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py", line 402, in get_error_attr_value
    error_message = self.substitute_error_message_references(error_message_attr, fp)
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py", line 386, in substitute_error_message_references
    error_message = re.sub(r"{(?P<name>[a-zA-Z_0-9.]+)}", substitute_ref, error_message)
  File "/usr/lib/python3.8/re.py", line 210, in sub
    return _compile(pattern, flags).sub(repl, string, count)
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py", line 375, in substitute_ref
    val = self.evaluate_reference(
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/vm/virtual_machine_base.py", line 340, in evaluate_reference
    reference = flow_tracking_data.resolve_reference(
  File "/home/gaetan/cairo_venv/lib/python3.8/site-packages/starkware/cairo/lang/compiler/preprocessor/flow.py", line 143, in resolve_reference
    raise MissingReferenceError(f"Missing reference {name}.")
starkware.cairo.lang.compiler.preprocessor.flow.MissingReferenceError: Missing reference __main__.X.
=========================== short test summary info ============================
FAILED tests/test_r_place.py::test_play_x_invalid - AssertionError
============================== 1 failed in 5.79s ===============================
